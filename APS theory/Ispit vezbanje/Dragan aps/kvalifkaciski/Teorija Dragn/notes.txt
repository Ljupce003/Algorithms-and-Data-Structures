					predavanie 2
Еднострано поврзани листи и ДЛЛ разликата
е што има два покажувачи еден цурр и еден пред
 Подреденоста на елементите се запазува,
меѓутоа нема потреба да има и мемориски
континуитет
 Репрезентација: множество на подредени
елементи, каде секој елемент е опишан со
вредност на јазелот(теме) (data) и покажувач кон
следниот јазел (link)
• Податочни структури кои не зафаќаат
континуиран мемориски простор
• Покажувачите се клучните податочни типови
како врски кои ги држат елементите на листата
во компактна целина.
• Предности:
	– листите никогаш не можат да се наполнат и секогаш
	ќе има место за додавање на нови елементи (освен
	доколку не се наполни меморијата)
	– додавањето и бришењето на елемент е поедноставно
	отколку кај низите (кај кои при овие операции
	останатите елементи треба да се поместуваат).
• Недостатоци:
	– кај листите потребна е дополнителна меморија за
	чување на покажувачите (следбениците) кои реално
	не носат корисна информација
	– листите не овозможуваат ефикасен пристап до
	произволен елемент, туку треба да се измине цела
	листа за да се стигне до даден елемент

					predavanie 4 i av 6
Еднодимензионални податочни структури
 Апстрактни податочни типови - АПТ

 Стек (Stack) / Магацин
	Еднодимензионална линеарна секвенца од
	елементи според принципот
	последен-внесен прв-изваден(LIFO)
	Длабочина на стек – број на елемени што ги
	содржи
	 Празен стек има длабочина 0
	 Додавање елемент на врвот на стекот (операција
	“push”)
	 Вадење елемент од врвот на стекот (операција “pop”)
	 проверка на првиот елемент во
	стекот без негово вадење/ бришење("peek")
	 Елементите во секвенцата можат да се додаваат и
	вадат само на едниот нејзин крај – врв на стекот
	• Постојат две генерални имплементации на стек:
		– Ограничен стек – кој се имплементира со 
		користење на низа.
		– Неограничен стек – кој се имплементира со
		користење на листа.

 Редица (Queue)
	Еднодимензионална линеарна секвенца од
	елементи според принципот прв-внесен-првизваден(FIFO)
	 Елементите во секвенцата можат да се додаваат на
	едниот крај (опашот), а вадат другиот крај (главата)
	на редицата
	 Додавање елемент на опашот од редицата
	(операција “en-queue”)
	 Вадење елемент од главата на редицата (операција
	“de-queue”)
	 Дополнително, проверка на елементот на главата на
	редицата без негово вадење/ бришење ("peek").
	разделување - "demerging"
	• Постојат две генерални имплементации на
	редица:
		– Ограничена редица – која се имплементира со
		користење на низа
		– Неограничена редица – кој се имплементира со
		користење на листа

 Приоритетна редица (Priority queue)
	 Еднодимензионална линеарна секвенца од
	елементи, каде секој елемент има свој
	приоритет.
	 Елементот со наголем приоритет секогаш прв се
	вади од листата
	Приоритетна редица - имплементација
	 Две можности при имплементација
		1. Подредена редица
		2. Неподредена редица
	 И двете се независни од фундаменталниот
	податочен тип што ќе се користи (во однос на
	перформансите)
	• Постојат две генерални имплементации на
	редица:
		– Ограничена редица – која се имплементира со
		користење на низа
		– Неограничена редица – кој се имплементира со
		користење на листа

Техника на груба сила (brute force)
	 Наједноставна техника за решавање на
	проблеми
	 Ги испитува сите можни случаи преку кои се
	доаѓа до резултатот
	 Гарантира дека ќе најде резултат
	Недостаток: Преголемо време и мемориски ресурси за
	извршување на ваквите алгоритми
	
Архетипи на алгорими
	 алчни (максималистички)
		 секогаш го бараат локалното оптималнo
		решение
		 најчесто креираат коректно решение но, само за
		дел од проблемскиот домен
		 работат релативно брзо
		 даваат приближни резултати
	
	 раздели и владеј
		 Во принцип секогаш резултира во коректен
		алгоритам
		 Се состои од два чекора:
			1. Раздели: Проблемот се дели на помали проблеми се
			додека не се дојде до елементарни или базични
			случаи
			2. Владеј: Решението на проблемот се добива од
			решенијата на поедноставните проблеми со помош
			на така наречено „слевање“ на решението
			 Решенијата најчесто се добиваат со користење
			на рекурзија
		 Класи на проблеми во кои е применлива
		раздели и владеј парадигмата:
			 геометриски проблеми (најблиски точки во рамнина,
			најмал конвексен полигон кој опфаќа множество точки)
			 пресметувачки проблеми (брза фуриева
			трансформација, множење на матрици)
			 проблеми кои работат со графови
		Раздели и владеј се употребува кога исти потпроблеми не
		се пресметуваат повеќе пати.
	
	 динамичко програмирање
		 Динамичко програмирање се применува кај
		проблеми (функции) што се преклопуваат
		 Користи дополнителна меморија за да ги
		сочувува резултатите на подпроблемите
		 Постојат два пристапа за имплементирање на
		динамичкото програмирање:
			1. „одозгора – надолу“ пристап (top – down)
			2. „одоздола – нагоре“ пристап (bottom –up)
		 Клучот за решавање на задачите со динамичко
		програмирање е во наоѓање на добра состојбa
		што ќе се запамети
		 Состојбата треба да не зазема многу меморија
		 Доплонително, потребно е да нема преголем
		број на состојби, со што значително би се
		заштедиле мемориските побарувања кои би ги
		имала програмата.
		 Динамичкото програмирање вообичаено се
		употребува кај проблеми каде што се бара
		некаква оптимизација
		 Во ваквите проблеми се можни повеќе решенија
		 Секое решение си има своја вредност, и ние се
		стремиме да го пронајдеме решението со
		најпосакуваната вредност
	
	 алгоритми со случајни броеви и
		
	 алгоритми кои се враќаат наназад од резултатот	
		 Припаѓаат на типот на алгоритми „груба сила“
		 Ги препознаваат патеките кои не водат до резултатот
		 На овој начин ги отфрлаат непотребните
		извршувања и проверки
		 Зголемување на ефикасноста на алгоритмот


*наследувањетп во јава е is-a наспроти has-a во C
• Генериците овозможуваат типовите (класи
и интерфејси) да бидат параметризирани
во фазата на нивната дефиниција 


• Сортирања со споредба
 – Сортирање со вметнување - Insertion sort
 – Сортирање со меурчиња - Bubble sort
 – Сортирање со спојување - Merge sort
 – Брзо сортирање - Quick sort
• Сортирања без споредба
 – Сортирање со броење - Counting sort
 – Сортирање со „кофички“ - Bucket sort
 – Radix sort